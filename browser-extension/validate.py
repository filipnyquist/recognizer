#!/usr/bin/env python3
"""
Test script to validate browser extension structure and generate test models
"""

import json
import os
import sys
from pathlib import Path

def validate_extension_structure():
    """Validate that all required files exist for the browser extension"""
    
    extension_dir = Path(__file__).parent
    print(f"Validating extension structure in: {extension_dir}")
    
    required_files = [
        'manifest.json',
        'background.js', 
        'content.js',
        'popup.html',
        'popup.js',
        'ai-engine.js',
        'inject.js',
        'models/config.json',
        'README.md'
    ]
    
    missing_files = []
    for file_path in required_files:
        full_path = extension_dir / file_path
        if not full_path.exists():
            missing_files.append(file_path)
        else:
            print(f"‚úì {file_path}")
    
    if missing_files:
        print("\n‚úó Missing files:")
        for file_path in missing_files:
            print(f"  - {file_path}")
        return False
    
    print("\n‚úì All required files present")
    return True

def validate_manifest():
    """Validate manifest.json structure"""
    
    extension_dir = Path(__file__).parent
    manifest_path = extension_dir / 'manifest.json'
    
    try:
        with open(manifest_path) as f:
            manifest = json.load(f)
        
        required_keys = ['manifest_version', 'name', 'version', 'permissions']
        for key in required_keys:
            if key not in manifest:
                print(f"‚úó Missing required key in manifest: {key}")
                return False
        
        if manifest['manifest_version'] != 3:
            print(f"‚úó Expected manifest_version 3, got {manifest['manifest_version']}")
            return False
            
        print("‚úì Manifest structure valid")
        return True
        
    except Exception as e:
        print(f"‚úó Error validating manifest: {e}")
        return False

def validate_model_config():
    """Validate model configuration"""
    
    extension_dir = Path(__file__).parent
    config_path = extension_dir / 'models' / 'config.json'
    
    try:
        with open(config_path) as f:
            config = json.load(f)
        
        required_sections = ['models', 'labels']
        for section in required_sections:
            if section not in config:
                print(f"‚úó Missing section in config: {section}")
                return False
        
        required_models = ['yolo', 'clip_vision', 'clip_text', 'clipseg']
        for model in required_models:
            if model not in config['models']:
                print(f"‚úó Missing model config: {model}")
                return False
        
        print("‚úì Model configuration valid")
        return True
        
    except Exception as e:
        print(f"‚úó Error validating model config: {e}")
        return False

def create_dummy_models():
    """Create dummy ONNX model files for testing"""
    
    extension_dir = Path(__file__).parent
    models_dir = extension_dir / 'models'
    
    # This creates empty files as placeholders
    # In real usage, these would be generated by convert_models.py
    dummy_models = [
        'yolo11m-seg.onnx',
        'clip_vision_encoder.onnx', 
        'clip_text_encoder.onnx',
        'clipseg.onnx'
    ]
    
    created = []
    for model_name in dummy_models:
        model_path = models_dir / model_name
        if not model_path.exists():
            # Create a small dummy file
            with open(model_path, 'w') as f:
                f.write(f"# Dummy ONNX model file: {model_name}\n")
                f.write("# This is a placeholder - run convert_models.py to generate real models\n")
            created.append(model_name)
    
    if created:
        print(f"\n‚úì Created dummy model files: {', '.join(created)}")
        print("‚ö†Ô∏è  Run 'python convert_models.py' to generate real ONNX models")
    else:
        print("\n‚úì Model files already exist")

def generate_extension_package_info():
    """Generate information for packaging the extension"""
    
    extension_dir = Path(__file__).parent
    
    print(f"\nüì¶ Extension Package Information:")
    print(f"Location: {extension_dir.absolute()}")
    print(f"Size: {sum(f.stat().st_size for f in extension_dir.rglob('*') if f.is_file())} bytes")
    
    print(f"\nüìã Installation Instructions:")
    print(f"1. Open Chrome/Edge and go to chrome://extensions/")
    print(f"2. Enable 'Developer mode' (toggle in top right)")
    print(f"3. Click 'Load unpacked' and select: {extension_dir.absolute()}")
    print(f"4. The reCognizer extension should appear with a üé≠ icon")
    
    print(f"\nüß™ Testing Sites:")
    print(f"- https://recaptcha-demo.appspot.com/recaptcha-v2-checkbox-explicit.php")
    print(f"- https://www.google.com/recaptcha/api2/demo")
    print(f"- https://patrickhlauke.github.io/recaptcha/")

def main():
    """Main validation function"""
    
    print("üé≠ reCognizer Browser Extension Validator")
    print("=" * 50)
    
    success = True
    
    # Validate structure
    if not validate_extension_structure():
        success = False
    
    # Validate manifest
    if not validate_manifest():
        success = False
    
    # Validate model config  
    if not validate_model_config():
        success = False
    
    # Create dummy models if needed
    create_dummy_models()
    
    # Show package info
    generate_extension_package_info()
    
    if success:
        print(f"\n‚úÖ Extension validation passed!")
        print(f"Ready to load as unpacked extension in Chrome/Edge")
    else:
        print(f"\n‚ùå Extension validation failed!")
        print(f"Please fix the issues above before loading")
        sys.exit(1)

if __name__ == "__main__":
    main()